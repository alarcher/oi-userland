--- torque-5.1.1.orig/src/daemon_client/trq_auth_daemon.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/daemon_client/trq_auth_daemon.c	2017-01-20 18:42:38.058730863 +0100
@@ -318,7 +318,7 @@
     }
 
   mypid = getpid();
-  sprintf(write_buf, "%d|%d|%s|%d|", TRQ_DOWN_TRQAUTHD, (int )strlen(pwent->pw_name), pwent->pw_name, mypid);
+  sprintf(write_buf, "%d|%d|%s|%ld|", TRQ_DOWN_TRQAUTHD, (int )strlen(pwent->pw_name), pwent->pw_name, mypid);
 
   if((rc = connect_to_trqauthd(&sock)) != PBSE_NONE)
     {
--- torque-5.1.1.orig/src/include/mom_func.h	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/include/mom_func.h	2017-01-20 18:42:38.126166507 +0100
@@ -245,7 +245,9 @@
 extern void  state_to_server(int, int);
 extern void  dep_main_loop_cycle(void);
 extern int   message_job(job *, enum job_file, char *);
+#ifdef __linux__
 extern proc_stat_t *get_proc_stat(int pid);
+#endif
 
 extern void  term_job(job *);
 int          TTmpDirName(job *, char *, int);
--- torque-5.1.1.orig/src/lib/Libattr/attr_node_func.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libattr/attr_node_func.c	2017-01-20 18:42:38.173560230 +0100
@@ -825,7 +825,7 @@
   long offset = 0;
   if (offsetGiven)
     {
-    offset = tm.tm_gmtoff; //Save the offset, mktime puts in its own.
+    offset = (tm.tm_isdst > 0 ? altzone : timezone); //Save the offset, mktime puts in its own.
     }
   time_t givenEpoch = mktime(&tm);
   if (offsetGiven)
@@ -837,12 +837,12 @@
        Time entered 2014-08-20T00:00:00-04
        Machine on west coast will see that as 2014-08-19T20:00:00-08
        */
-    givenEpoch += tm.tm_gmtoff; //Take away the calculated offset.
+    givenEpoch += (tm.tm_isdst > 0 ? altzone : timezone); //Take away the calculated offset.
     givenEpoch -= offset;       //Add in the passed in offset.
     }
   else
     {
-    givenEpoch += tm.tm_gmtoff; //Take away the calculated offset.
+    givenEpoch += (tm.tm_isdst > 0 ? altzone : timezone); //Take away the calculated offset.
     }
   if(givenEpoch <= time(NULL))
     {
--- torque-5.1.1.orig/src/lib/Libifl/pbsD_connect.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libifl/pbsD_connect.c	2017-01-20 18:42:38.310174679 +0100
@@ -110,6 +110,10 @@
 #if HAVE_SYS_UIO_H
 #include <sys/uio.h>
 #endif
+#ifdef __sun
+#include <sys/sockio.h>
+#undef s_addr
+#endif
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -704,7 +708,7 @@
      * trq_system|trq_port|Validation_type|user|pid|psock|
      */
     mypid = getpid();
-    sprintf(write_buf, "%d|%d|%s|%d|%d|%d|%s|%d|%d|", TRQ_AUTH_CONNECTION, (int)strlen(server_name), server_name, server_port, AUTH_TYPE_IFF, (int)strlen(pwent->pw_name), pwent->pw_name, mypid, parent_client_socket);
+    sprintf(write_buf, "%d|%d|%s|%d|%d|%d|%s|%ld|%d|", TRQ_AUTH_CONNECTION, (int)strlen(server_name), server_name, server_port, AUTH_TYPE_IFF, (int)strlen(pwent->pw_name), pwent->pw_name, mypid, parent_client_socket);
     /*
      * total_length|val
      */
--- torque-5.1.1.orig/src/lib/Libifl/tm.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libifl/tm.c	2017-01-20 18:42:38.426088129 +0100
@@ -81,8 +81,8 @@
 #include <pbs_config.h>   /* the master config generated by configure */
 
 /* define the following so we get prototype for getsid() */
-#define _XOPEN_SOURCE
-#define _XOPEN_SOURCE_EXTENDED 1
+//#define _XOPEN_SOURCE
+//#define _XOPEN_SOURCE_EXTENDED 1
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -179,7 +179,7 @@
   struct stat sbuf;
 
   /* build path to pid */
-  snprintf(path, sizeof(path), "/proc/%d", pid);
+  snprintf(path, sizeof(path), "/proc/%ld", pid);
 
   /* do the stat */
   /*   if it fails, assume not owner */
--- torque-5.1.1.orig/src/lib/Libifl/trq_auth.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libifl/trq_auth.c	2017-01-20 18:42:38.429505173 +0100
@@ -20,6 +20,7 @@
 #include <stdarg.h>
 #include <string.h>
 #include <string>
+#include <ucred.h>
 
 #define MAX_RETRIES 5
 
@@ -646,9 +647,11 @@
   char       *msg)
 
   {
-  struct ucred   cr;
-  socklen_t      cr_size;
+  ucred_t * cr;
   struct passwd *user_pwd;
+  uid_t euid;
+  gid_t gid;
+  pid_t pid;
 
   if (msg == NULL)
     return(PBSE_BAD_PARAMETER);
@@ -659,18 +662,32 @@
     return(PBSE_BAD_PARAMETER);
     }
 
-  cr_size = sizeof(struct ucred);
-  if (getsockopt(sock, SOL_SOCKET, SO_PEERCRED, (void *)&cr, &cr_size) < 0)
-    {
-    sprintf(msg, "getsockopt for SO_PEERDRED failed: %d", errno);
-    return(PBSE_SOCKET_FAULT);
-    }
+  if (getpeerucred(sock, &cr) == -1)
+  {
+  sprintf(msg, "getpeerucred failed: %d", errno);
+  return(PBSE_SOCKET_FAULT);
+  }
+  if ((euid = ucred_geteuid(cr)) == (uid_t)-1)
+  {
+  sprintf(msg, "ucred_geteuid failed: %d", errno);
+  return(PBSE_SOCKET_FAULT);
+  }
+  if ((gid = ucred_getrgid(cr)) == (gid_t)-1)
+  {
+  sprintf(msg, "ucred_getrgid failed: %d", errno);
+  return(PBSE_SOCKET_FAULT);
+  }
+  if ((pid = ucred_getpid(cr)) == (pid_t)-1)
+  {
+  sprintf(msg, "ucred_getpid failed: %d", errno);
+  return(PBSE_SOCKET_FAULT);
+  }
 
-  user_pwd = get_password_entry_by_uid(cr.uid);
+  user_pwd = get_password_entry_by_uid(euid);
    
   if (user_pwd == NULL)
     {
-    sprintf(msg, "UID %d returned NULL from getpwuid", cr.uid);
+    sprintf(msg, "UID %d returned NULL from getpwuid", euid);
     return(PBSE_IFF_NOT_FOUND);
     }
 
@@ -680,12 +697,13 @@
     return(PBSE_IFF_NOT_FOUND);
     }
 
-  if (cr.pid != user_pid)
+  if (pid != user_pid)
     {
-    sprintf(msg, "invalid pid: submitted: %d, expected: %d", user_pid, cr.pid);
+    sprintf(msg, "invalid pid: submitted: %d, expected: %ld", user_pid, pid);
     return(PBSE_IFF_NOT_FOUND);
     }
 
+  ucred_free(cr);
   return(PBSE_NONE);
   }
 
--- torque-5.1.1.orig/src/lib/Liblog/pbs_log.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Liblog/pbs_log.c	2017-01-20 18:42:38.584318628 +0100
@@ -145,7 +145,7 @@
 static int      syslogopen = 0;
 #endif /* SYSLOG */
 
-pthread_mutex_t log_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 /* variables for job logging */
 static int      job_log_auto_switch = 0;
@@ -779,7 +779,7 @@
   int eventclass = 0;
   char time_formatted_str[64];
 
-  thr_id = syscall(SYS_gettid);
+  thr_id = pthread_self();
   pthread_mutex_lock(&log_mutex);
 
 #if SYSLOG
@@ -855,7 +855,7 @@
       if (eventclass != PBS_EVENTCLASS_TRQAUTHD)
         {
         rc = fprintf(logfile,
-              "%02d/%02d/%04d %02d:%02d:%02d.%03d;%02d;%10.10s.%d;%s;%s;%s%.*s\n",
+              "%02d/%02d/%04d %02d:%02d:%02d.%03d;%02d;%10.10s.%ld;%s;%s;%s%.*s\n",
               ptm->tm_mon + 1,
               ptm->tm_mday,
               ptm->tm_year + 1900,
--- torque-5.1.1.orig/src/lib/Libnet/net_client.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libnet/net_client.c	2017-01-20 18:42:38.595803056 +0100
@@ -100,12 +100,95 @@
 #include <arpa/aixrcmds.h>
 #endif
 
-#ifdef __APPLE__
-/* this is a hack for the missing bindresvport declaration on OS X
-   the function works fine but its use will generate a compiler warning
-   if -Wall is used with gcc */
-int bindresvport(int sd, struct sockaddr_in *sin);
-#endif
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netinet/udp.h>
+#include <string.h>
+#include <unistd.h>
+
+#define	bzero(s, len)	(void) memset((s), 0, (len))
+
+/*
+ * Bind a socket to a privileged IP port
+ */
+int
+bindresvport(int sd, struct sockaddr_in *sin)
+{
+	struct sockaddr_in myaddr;
+	struct sockaddr_in *bindaddr;
+	int level, optname;
+	int optval, len;
+	int ret;
+
+	bindaddr = sin;
+	if (bindaddr == (struct sockaddr_in *)0) {
+		bindaddr = &myaddr;
+		bzero(bindaddr, sizeof (*bindaddr));
+		bindaddr->sin_family = AF_INET;
+	} else if (bindaddr->sin_family != AF_INET) {
+		errno = EPFNOSUPPORT;
+		return (-1);
+	}
+
+	len = sizeof (optval);
+	if (getsockopt(sd, SOL_SOCKET, SO_TYPE, &optval, (Psocklen_t) &len) < 0) {
+		return (-1);
+	}
+	/*
+	 * Use *_ANONPRIVBIND to ask the kernel to pick a port in the
+	 * priviledged range for us.
+	 */
+	if (optval == SOCK_STREAM) {
+		level = IPPROTO_TCP;
+		optname = TCP_ANONPRIVBIND;
+	} else if (optval == SOCK_DGRAM) {
+		level = IPPROTO_UDP;
+		optname = UDP_ANONPRIVBIND;
+	} else {
+		errno = EPROTONOSUPPORT;
+		return (-1);
+	}
+
+	optval = 1;
+	if (setsockopt(sd, level, optname, &optval, sizeof (optval)) < 0) {
+		return (-1);
+	}
+
+	bindaddr->sin_port = 0;
+	ret = bind(sd, (struct sockaddr *)bindaddr,
+	    sizeof (struct sockaddr_in));
+
+	/*
+	 * Always turn off the option when we are done.  Note that by doing
+	 * this, if the caller has set this option before calling
+	 * bindresvport(), it will be unset.  But this should never happen...
+	 */
+	optval = 0;
+	(void) setsockopt(sd, level, optname, &optval, sizeof (optval));
+
+	if (ret >= 0 && sin != NULL) {
+		/*
+		 * Historical note:
+		 *
+		 * Past versions of this bindresvport() code have
+		 * returned with the reserved port number bound
+		 * filled in its "sin" parameter (if passed in), perhaps
+		 * "accidently" because of the structure of historical code.
+		 *
+		 * This is not documented but the behavior is
+		 * explicitly retained here for compatibility to minimize
+		 * risk to applications, even though it is not clear if this
+		 * was a design intent.
+		 */
+		len = sizeof (struct sockaddr_in);
+		(void) getsockname(sd, (struct sockaddr *)bindaddr, (Psocklen_t) &len);
+	}
+	return (ret);
+}
+
 
 /**
  * Returns the max number of possible file descriptors (as
@@ -218,7 +301,7 @@
 
   len = sizeof(val);
 
-  rc = getsockopt(sockd, SOL_SOCKET, SO_ERROR, &val, &len);
+  rc = getsockopt(sockd, SOL_SOCKET, SO_ERROR, &val, (unsigned int *) &len);
 
   if ((rc == 0) && (val == 0))
     {
--- torque-5.1.1.orig/src/lib/Libnet/net_common.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libnet/net_common.c	2017-01-20 18:42:38.601926318 +0100
@@ -27,6 +27,7 @@
 #include "log.h" /* LOCAL_LOG_BUF_SIZE */
 #include "net_cache.h"
 #include "mutex_mgr.hpp"
+#include <sys/filio.h>
 
 #include "pbs_error.h" /* torque error codes */
 
--- torque-5.1.1.orig/src/lib/Libnet/net_server.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libnet/net_server.c	2017-01-20 18:42:38.603237438 +0100
@@ -920,12 +920,12 @@
   if (sock_type == PBS_SOCK_INET)
     {
     fromsize = sizeof(from);
-    newsock = accept(sd, (struct sockaddr *) & from, &fromsize);
+    newsock = accept(sd, (struct sockaddr *) & from, (Psocklen_t) &fromsize);
     }
   else
     {
     fromsize = sizeof(unixfrom);
-    newsock = accept(sd, (struct sockaddr *) & unixfrom, &fromsize);
+    newsock = accept(sd, (struct sockaddr *) & unixfrom, (Psocklen_t) &fromsize);
     }
 
   if (newsock == -1)
--- torque-5.1.1.orig/src/lib/Libnet/port_forwarding.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libnet/port_forwarding.c	2017-01-20 18:42:38.604470360 +0100
@@ -103,7 +103,7 @@
           {
           int newsock = 0, peersock = 0;
 
-          if ((sock = accept((socks + n)->sock, (struct sockaddr *) & from, &fromlen)) < 0)
+          if ((sock = accept((socks + n)->sock, (struct sockaddr *) & from, (Psocklen_t) &fromlen)) < 0)
             {
             if ((errno == EAGAIN) || (errno == EWOULDBLOCK) || (errno == EINTR) || (errno == ECONNABORTED))
               continue;
@@ -236,7 +236,7 @@
 
   optlen = sizeof(opt);
 
-  if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1)
+  if (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, (Psocklen_t) &optlen) == -1)
     {
     fprintf(stderr, "getsockopt TCP_NODELAY: %.100s", strerror(errno));
     return;
--- torque-5.1.1.orig/src/lib/Libnet/rm.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/lib/Libnet/rm.c	2017-01-20 18:42:38.610890764 +0100
@@ -111,6 +111,14 @@
 extern int pbs_errno;
 static int full = 1;
 
+#ifdef __sun
+/* this is a hack for the missing bindresvport declaration on OS X
+   the function works fine but its use will generate a compiler warning
+   if -Wall is used with gcc */
+int bindresvport(int sd, struct sockaddr_in *sin);
+#endif
+
+
 /*
 ** This is the structure used to keep track of the resource
 ** monitor connections.  Each entry is linked into as list
--- torque-5.1.1.orig/src/scheduler.cc/pbs_sched.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/scheduler.cc/pbs_sched.c	2017-01-20 18:42:39.794010715 +0100
@@ -628,7 +628,7 @@
 
   slen = sizeof(saddr);
 
-  new_socket = accept(sock, (struct sockaddr *) & saddr, &slen);
+  new_socket = accept(sock, (struct sockaddr *) & saddr, (Psocklen_t) &slen);
 
   if (new_socket == -1)
     {
--- torque-5.1.1.orig/src/server/array_func.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/array_func.c	2017-01-20 18:42:39.965785346 +0100
@@ -1431,8 +1431,8 @@
     {
     return 0;
     }
-  idx = index(str, '-');
-  ridx = rindex(str, '-');
+  idx = strchr(str, '-');
+  ridx = strrchr(str, '-');
 
   /* token is not a range, parse it as a single task id */
   if (idx == NULL)
--- torque-5.1.1.orig/src/server/incoming_request.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/incoming_request.c	2017-01-20 18:42:39.969899727 +0100
@@ -94,6 +94,8 @@
 #include "net_connect.h"
 #include "batch_request.h"
 
+#undef s_addr
+
 const int SHORT_TIMEOUT = 5;
 
 char *netaddr(struct sockaddr_in *ap);
@@ -109,7 +111,7 @@
   int          protocol_type;
   // we don't want to get all threads stuck polling for input, so make sure that
   // we have a short timeout to start.
-  if (timeout > pbs_tcp_timeout)
+  if (timeout > (unsigned int) pbs_tcp_timeout)
     timeout = pbs_tcp_timeout;
 
   protocol_type = disrui_peek(chan, &rc, timeout);
@@ -118,7 +120,7 @@
     {
     // If we aren't too busy try again. If we are too busy just move on so we
     // don't completely jam ourselves.
-    if ((timeout < pbs_tcp_timeout) &&
+    if ((timeout < (unsigned int) pbs_tcp_timeout) &&
         (threadpool_is_too_busy(request_pool, ATR_DFLAG_MGRD) == false))
       {
       chan->IsTimeout = 0;
--- torque-5.1.1.orig/src/server/job_func.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/job_func.c	2017-01-20 18:42:39.975355428 +0100
@@ -1003,8 +1003,8 @@
     return(NULL);
     }
 
-  bracket = index(oldid,'[');
-  hostname = index(oldid, '.');
+  bracket = strchr(oldid,'[');
+  hostname = strchr(oldid, '.');
 
   if (bracket != NULL)
     {
--- torque-5.1.1.orig/src/server/node_power_state.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/node_power_state.c	2017-01-20 18:42:40.021381956 +0100
@@ -197,7 +197,7 @@
       }
 
     int sock;
-    if ((sock = socket(AF_INET,SOCK_PACKET,SOCK_PACKET)) < 0)
+    if ((sock = socket(AF_INET,SOCK_RAW,SOCK_RAW)) < 0)
       {
       return PBSE_SYSTEM;
       }
--- torque-5.1.1.orig/src/server/pbsd_main.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/pbsd_main.c	2017-01-20 18:42:40.026217173 +0100
@@ -2840,7 +2840,7 @@
 static int daemonize_server(
 
   int  DoBackground,  /* I */
-  int *sid)           /* O */
+  pid_t *sid)           /* O */
 
   {
   int    pid;
--- torque-5.1.1.orig/src/server/req_quejob.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/req_quejob.c	2017-01-20 18:42:40.042595348 +0100
@@ -1476,7 +1476,7 @@
        actions applied to id[] are applied to the entire array */
     oldid = strdup(pj->ji_qs.ji_jobid);
 
-    hostname = index(oldid, '.');
+    hostname = strchr(oldid, '.');
 
     if (hostname != NULL)
       {
--- torque-5.1.1.orig/src/server/req_runjob.c	2015-05-27 18:21:28.000000000 +0200
+++ torque-5.1.1/src/server/req_runjob.c	2017-01-20 18:42:40.045503075 +0100
@@ -1174,7 +1174,7 @@
         char tmpLine[MAXLINE];
         sprintf(tmpLine,
           "Unexpected length for email's text: '%ld' - discarded as a corrupted field",
-          preq->rq_reply.brp_un.brp_txt.brp_txtlen);
+          (long int) preq->rq_reply.brp_un.brp_txt.brp_txtlen);
         log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, job_id, tmpLine);
         }
       }
